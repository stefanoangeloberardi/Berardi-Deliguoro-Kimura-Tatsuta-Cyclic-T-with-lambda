% lmcs, 2018.5.2, 2019.9.9, 2020.2.10



\newif\ifdraft \draftfalse
\drafttrue % put % for lipics


\long\def\Stefano#1{{{\color{red}{SB: #1}}}}
\long\def\Makoto#1{{{\color{blue}{MT: #1}}}}
\long\def\Daisuke#1{{{\color{green}{DK: #1}}}}

\ifdraft

\documentclass{article}
\usepackage{mystyle}
\A4page

\else

\documentclass{lmcs}
\usepackage{hyperref}
%\usepackage{amsmath}heoremstyle{plain}\newtheorem{satz}[thm]{Satz} %\crefname{satz}{Satz}{\Succ    atze}

\fi

\usepackage{mymath,proof,latexsym}
\usepackage{xcolor}
\usepackage[pdftex,outline]{contour}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AGGIUNGO TEOREMA LEMMA PROPOSIZIONE COROLLARIO PROVA % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


\begin{document}
\sloppy 
\hbadness=10000
\vbadness=10000

\input{macro}

\ifdraft

\title{CT-$\lambda$, a cyclic simply typed $\lambda$-calculus with fixed points}

\author{Stefano Berardi,  Ugo de' Liguoro, Daisuke Kimura, Koji Nakazawa, Makoto Tatsuta}
\date{}

\else

\title[Equivalence]{}

\author[S. Berardi]{Stefano Berardi}
\address{Universit\`{a} di Torino,
Torino, Italy}
\email{stefano@unito.it}


%% mandatory lists of keywords 
\keywords{
proof theory
inductive definitions
Brotherston-Simpson conjecture
cyclic proofs
}
\fi

\maketitle

\begin{abstract}
A motivation for having a circular syntax for G\"{o}del System $\systemT$ is that terms 
in a circular syntax are much shorter than the equivalent terms written in $\systemT$, 
yet they can be checked mechanically.

Several circular syntax for $\systemT$ have been proposed.
In this paper explore the possibility of defining a circular syntax
directly for $\lambda$-abstraction and simple types, instead of interpreting
 $\lambda$-abstraction through combinators first, then inserting a  circular syntax afterwards.
A circular syntax using binders instead of combinators
could be more familiar for researchers working in the field of Type Theory.

We introduce our circular syntax as a fixed point operator defined by cases through a test on $0$.
We prove the expected results for this circular simply typed $\lambda$-calculus, which we call $\CTlambda$: 
\emph{(i)} every closed term of type $\N$ reduces to some numeral;
\emph{(ii)}  strong normalization for all reductions sequences outside all fixed points; 
\emph{(iii)}  strong normalization for ``fair'' reductions; \emph{(iv)} Church-Rosser property;
and \emph{(v)} the inclusion between terms of G\"{o}del system $\systemT$
inside the terms of $\CTlambda$. 
We conjecture the equivalence between $\systemT$ and $\CTlambda$,
a similar result but without a binder operator $\lambda$ was already obtained by Anupam.



\end{abstract}

\iffalse
key words: 
proof theory,
inductive definitions,
Brotherston-Simpson conjecture,
cyclic proofs,
Martin-Lof's system of inductive definitions,
infinite Ramsey theorem
Podelski-Rybalchenko termination theorem
size-change termination theorem
\fi




\section{Introduction}
We will introduce $\LAMBDA$, a set of infinite $\lambda$-terms with a circular syntax.
The types of $\LAMBDA$ are: the atomic type $\N$, 
possibly type variables $\alpha, \beta, \ldots$, and all types $A \rightarrow B$ for any types $A$, $B$. 
Type variables are only used to provide examples and play a minor role in our paper.

The terms of $\LAMBDA$  are possibly infinite trees representing expressions defined with 
$0$,$\Succ $,$\ap$ (application), 
variables $x^T$ with a type superscript,  $\lambda$ (the binder for defining maps), 
and $\cond$, a fixed point binder operator for the arithmetic conditional (i.e., for test on zero). 
If we have no type variables, the the trees in $\LAMBDA$ represent partial functionals on $\N$, 
provided we add reduction rules.

%19:42 19/04/2024

In this paper will consider the set of well-typed terms $\WTyped \subseteq \LAMBDA$,
of terms with a unique type for the term and all its subtypes. 
We will consider $\GTC \subseteq \WTyped$, the subset of well-typed circular 
$\lambda$-terms satisfying a condition called the global trace condition. 
Terms of $\GTC$ denote total functionals. 
We will consider $\Reg$, the subset of terms which are regular trees (having finitely
many subtrees). They are possibly infinite terms which are finitely presented, 
by a finite graph with possibly cycles.
Eventually, we introduce the topic of this paper, the system $\CTlambda$.
 $\CTlambda$ is $\GTC \cap \Reg$, that is, it consists of all well-typed circular 
$\lambda$-terms satisfying satisfying the global trace condition and which are
regulal trees. We will prove that $\CTlambda$ is a decidable subset of $\Reg$.
$\CTlambda$ is a new circular version of G\"{o}del system $\systemT$. 
Differently from all previous circular version of $\systemT$, our system $\CTlambda$
uses binders instead of combinators. 
The circular syntax has the advange of writing much shorter terms.
Besides, by introducing a circular syntax with binders, we hope to provide 
a circular syntax more familiar to researchers working in the field of Type Theory.

We will prove the expected results for the circular syntax $\CTlambda$:
strong normalization for reductions not inside any fixed point and Church-Rosser. 
We will prove normalization in the limit if we use reductions which are ``fair'':
fair reductions can reduce \emph{inside} fixed points, but they never forget entirely 
the task of reducing \emph{outside} all fixed points.

Eventually, we will prove that the closed terms $\CTlambda$ (those without free \emph{term} variables)
represent exactly the total computable functionals definable in G\"{o}del system $\systemT$
using $\N$ as only atomic type.


%14:57 17/04/2024
%21:08 19/04/2024


\section{The set of infinite $\lambda$-terms}
We define the set $\LAMBDA$ of infinite circular terms, the subset $\WTyped$
of well-typed terms and a reduction relation for them.

\begin{definition}[Types of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
The types of $\LAMBDA$ are: the type $\N$ of natural numbers, an infinite list 
$\alpha,\beta,\ldots$ of type variables, and with $A,B$ also  $A \rightarrow B$.
We call them simple types, \emph{types} for short. 

\item 
$\Type$ is the set of simples types.
\end{enumerate}
\end{definition}

We write $\Nat$ for the set of natural numbers: 
all $n \in \Nat$ are represented in $\LAMBDA$ by some 
expression of type $\N$ which we call a numeral.

\begin{definition}[Terms of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
The terms of $\LAMBDA$ 
are all possibly infinite trees we can define with $x^T$ (variable name with superscript $T \in \Type$), 
$\lambda x^T.t$ (binder, abstraction), 
$\ap(t,u)$, $0$, $\Succ (t)$ (successor of $t$), $\cond x^\N.(f,g)$ (binder and arithmetical conditional).

\item
$t$ is an immediate subterm of $\Succ(t)$, $f$, $g$ are  immediate subterm of $\cond x^\N.(f,g)$
and $t$, $u$ are  immediate subterm of $t(u)$.

\item 
The subterm relation is the reflexive and transitive closure of the immediate subterm relation.

\item
We write $\SubTerm(t)$ for the set of subterms of $t$. 

\item
$\Reg$ is the set of terms $t \in \LAMBDA$ such that $\SubTerm(t)$ is finite.
We call the terms of $\Reg$ the \emph{regular terms}.

\item
We write $\Tree(t)$ for the tree of all chains
$(t_1, \ldots, t_n)$, with $t_1=t$ and $t_{i+1}$ immediate subterm of $t_i$ for all $(i+1) \le n$.


\item
When $t = \Succ ^n(0)$ for some natural number $n \in \Nat$
we say that $t$ is a numeral. We write $\Num$ for the set of numeral.

\end{enumerate}
As usual, we abbreviate $\ap(t,u)$ with $t(u)$. 
\end{definition}

We use two different names for the operation $\ap(t,u)$: 
we call it $\ap$ when $u$ is not a variable and $\etaRule$ when $u$ is a variable. 
$\Num$ is the representation inside $\LAMBDA$ of the set $\Nat$ of natural numbers.
All numeral are finite terms of $\Lambda$. 
All finite well-typed typed $\lambda$-terms 
we can define with the rules above are finite terms of $\LAMBDA$.
Regular terms can be represented by the subterm relation restricted to $\SubTerm(t)$:
this relation defines a graph with possibly cicles.


An example of regular term: the term $t = \cond x^\N.(0,t)$. 
The set $\SubTerm(t)=\{t,0\}$ of subterms  of $t$ is finite, therefore $t$ is a regular term.
However, $\Tree(t)$ is an infinite tree (it includes itself as a subtree). 
The finite branches of $\Tree(t)$ are all $(t,t,t,\ldots,0)$, the unique infinite branch of $\Tree(t)$
is $(t,t,t,\ldots)$. 

In order to define the type of an infinite term, we first 
define the context for any term of $\LAMBDA$.

\begin{definition}[Types and Contexts of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
A  context of $\LAMBDA$ is any finite list $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ 
of pairwise distinct variables, each assigned to its $A_1, \ldots, A_n \in \Type$. 

\item
We write $\FV(\Gamma) = \{{x_1}^{A_1}, \ldots, {x_n}^{A_n}\}$.
We say that $\Gamma$ is a context for $t \in \LAMBDA$ and we write $\Gamma \vdash t$ 
if $\FV(t) \subseteq \FV(\Gamma)$.


\item
If $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ ,
$\Gamma' = (x'_1:A'_1, \ldots, x'_n:A'_{n'})$ are context of $\LAMBDA$, then we
write $\Gamma \sqsubseteq \Gamma'$ if $\Gamma$ is a sub-list of $\Gamma'$, that is,
if there is a (unique) increasing map $f:\{1,\ldots,n\} \rightarrow \{1,\ldots,n'\}$
such that $x_{i}=x'_{f(i)}$ and $A_{i}=A'_{f(i)}$ for all $i \in \{1,\ldots,n\}$.

\item
If $\Gamma$ is a context of $\LAMBDA$, then $\Gamma\setminus\{x^T:T\}$ is the context obtained
by removing $x_i^{A_i}:A_i$ from $\Gamma$ if $x_i^{A_i}=x^T$. 
If $x \not \in \FV(\Gamma)$ then $\Gamma\setminus\{x^T:T\} = \Gamma$.

\end{enumerate}
\end{definition}


%12:38 17/04/2024
%15:37 17/04/2024

From the context for a term we can define a context for each subterm of the term.
A context is a list of type assignment to variables: our variables already have a type superscript,
so a type assignment is redundant for our variables (not for our terms).
Yet, we add an assignment relation $x^T:T$ for uniformity with the notation $x:T$ 
in use in Type Theory.

%21:26 19/04/2024

\begin{definition}[Inherited Contexts of $\LAMBDA$]

Given any context $\Gamma$, any $t \in \Lambda$ and any subterm chain 
$\pi = (t_1, \ldots, t_n) \in \Tree(t)$, we define a unique inherited context for $t_n$ in $\pi$.
The inherited context is obtained by repeatedly adding $x^T:T$ to the context whenever we
cross a term $t_i = \lambda x^T.u_i$, while simultaneously removing $x^T:T$ from the previous
context, if it was there.
%08:00 20/04/024

\begin{enumerate}

\item
$t$ has inherited context $\Gamma$.

\item
Any binder on $x$ subtracts the variable $x$ from the context of its \emph{last} argument:
if $t = \lambda x^T.u, \cond x^\N.(f,g)$ has inherited context $\Delta$, 
then $u$ and $g$ have context $\Delta \setminus \{x^T:T\}, x^T$, 
while $f$ has  inherited context $\Delta$.

\item
In any other case the context of a term and of the immediate subterm are the same:
ff $t=\Succ(u), f(a)$ have inherited context $\Delta$,
 then $u,f,a$ have  inherited context $\Delta$.
\end{enumerate}
We abbreviate \emph{`` inherited context from $\Gamma$''} with \emph{context}
when $\Gamma$ is fixed.
\end{definition}



%The scope of the binder $\lambda x^T.t$ is $t$.
%The scope of the binder $\cond x^\N.(f,g)$ is $g$ ($f$ is \emph{not} in the scope of $\cond x^\N.(f,g)$).

We define typing rules for terms of $\LAMBDA$ and the subset $\WTyped$ of well-typed terms.
We intend well-typed in a strong sense: typing exists and it is unique for the term and for all its subterms.

The typing rules are the usual ones but for the conditional binder $\cond$, and for a fresh rule $\etaRule$
for typing the application $t(x^T)$ of a term  to a variable $x^T$. 
$\etaRule$ corresponds to an $\eta$-expansion and it introduces a global variable name $x^T$
for the first argument of $t$. 
As we said, $\etaRule$ is but a particular case of $\ap$ rule. 
We prefer to use a separate name for $\etaRule$ 
because of the special role that $\etaRule$ has in this paper.

%We have a single structural rule  $\struct_f$, which can be used for:
% weakening, variable permutation and variable renaming. 
We have a a single structural rule $\weak$ for extending a context $\Gamma$ to a context 
$\Gamma \sqsupseteq \Gamma'$. 
Variable permutation and variable renaming are conditionally derivable for the typing rules,
and therefore are not included as rules.


\begin{definition}[Typing rules of $\LAMBDA$]
Assume $\Gamma = {x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_1$ is a context.
%$\Delta = y_1:B_1, \ldots, y_n:B_m$ are sequents of length $n$, $m$ respectively. Suppose
%$f:\{1, \ldots, n\} \rightarrow \{1, \ldots, m\}$ is any injection, compatible with types
%in $\Gamma$, $\Delta$: we assume $A_i = B_{f(i)}$ for all $1 \le i \le n$.

\begin{enumerate}
%\item
%$\struct_f$-rule.
%If $t: \Gamma \vdash T$ then $t[ y_{f(1)}/x_1, \ldots,  y_{f(n)}/x_n]:\Delta \vdash T$
\item
$\weak$-rule (Weakening).
If $\Gamma,\Delta \vdash t:T$
then $\Gamma, x^A:A, \Delta \vdash t: T$

\item
$\etaRule$.
If $x^A \not \in \FV(\Gamma)$ is a variable and $\Gamma \vdash f: A \rightarrow B$
then $\Gamma, x^A : A \vdash f(x) :  B$.

\item
$\var$-rule.
If $x^A \in \Gamma$ then $\Gamma \vdash x^A:A$.

\item
$\ap$-rule.
If $\Gamma \vdash f:A \rightarrow B$ and $\Gamma \vdash a:A$
and $a$ is not a variable then $\Gamma \vdash f(a) : B$.

\item
$\lambda$-rule.
If $\Gamma, x^A:A \vdash b: B$
then $ \Gamma \vdash \lambda x^A.b :A \rightarrow B$.

\item
$0$-rule.
$\Gamma \vdash 0: \N$

\item
$\Succ$-rule.
If $\Gamma \vdash t:\N$ then $\Gamma \vdash \Succ (t):\N$.

\item
$\cond$-rule.
If $\Gamma \vdash  f :T$ and  $\Gamma, x^\N \vdash g : T$ 
then $\Gamma \vdash \cond x^\N.(f,g) : \N \rightarrow T$.
\end{enumerate}
We abbreviate $\emptyset \vdash  t:A$ with $\vdash t:A$.
\end{definition}


From the typing rules we define the proofs that a term is well-typed. 
Proofs are assignment of types to subterms, we do not have to precise which typing rules are used
because if we do not consider weakening rules each term can be derived by a unique rule.


\begin{definition}[Well-typed term of $\LAMBDA$]
Assume $\Pi:\SubTerm(t) \rightarrow \Type$ is an assignment of one type $B=\Pi(u)$ to each
subterm $u$ of $t$. Assume $\Gamma$ is a context of $t$ (i.e, $\FV(t) \subseteq \Gamma$). 
We write $\Pi: \Gamma \vdash t:A$, and we say that $\Pi$ is a proof of $\Gamma \vdash t:A$ if:
\begin{enumerate}
\item 
$\Pi(t) = A$
\item
Assume that:
\begin{enumerate}
\item
$\pi$ is a subterm chain from $t$ to $u$, 
\item
$u_1, \ldots, u_m$ are the immediate subterms of $u$ and $B_1=\Pi(u_1)$, \ldots, $B_n=\Pi(u_n)$
\item
$\Delta_1, \ldots, \Delta_m, \Delta$ are  the contexts inherited by the chains
$\pi \conc u_1, \ldots, \pi \conc u_m, \pi$ from $t$ to  $u_1, \ldots, u_m$.
\end{enumerate}
Then we require that for some $\Delta' \sqsubseteq \Delta$ the following rules are correct:
\[
\infer[(\weak)]
{ \Delta \prove u : B }
{
 \infer[(\typingRule)]
{  \Delta' \prove u : B  }
    {
      {   \Delta_1 \prove u_1:B_1}
       { \ldots }
	  {   \Delta_n \prove u_1:B_n}
    }
}
\]
for some non-weakening rule $\typingRule$.
\end{enumerate}
\end{definition}

Eventually we define the well-typed terms of $\LAMBDA$.

\begin{definition}[Well-typed term of $\LAMBDA$]
\begin{enumerate}
\item
$\Gamma \vdash t:A$ is true if and only if $\Pi:\Gamma \vdash t:A$ for some $\Pi$.
\item
$t \in \LAMBDA$ is well-typed if $\Pi:\Gamma \vdash t:A$ for some \emph{unique} proof
$\Pi$. 
\item
$\WTyped$ is the set of well-typed $t \in \LAMBDA$.
\end{enumerate}
%A proof $\Pi:\Gamma \vdash  t :T$ is canonical if all $\weak$-rules
%\begin{enumerate}
%\item
% either follow some $\lambda$-rule for a term $\lambda x^T.b$, and they introduce $x^T$ in the context,
%\item
%or follow some $\cond$-rule for a term $\cond x^\N.(f,g)$, and and they introduce $x^\N$ in the context,
%\end{enumerate}
\end{definition}

We provide some examples of well-typed and not well-typed terms.

\begin{enumerate}
\item
Some term in $\LAMBDA$ has no type, like the application $0(0)$ of the non-function $0$. 
Some terms have more than one type.
For instance if $t=\cond x^\N.(t,t)(0)$ we can prove $x^\N : \N \vdash t:A$ for all types $A \in \Type$. 
The proof $\Pi$ is defined by $\Pi(t)=A$, $\cond x^\N.(t,t) = \N \rightarrow A$ and $\Pi(0)=\N$
A term with two types has the leftmost branch infinite, as it is the case for $t$ above.
\item
We will prove that if all subterms of a term have the leftmost branch finite, then the term has at most
one typing proof. If the term is also regular then we can decide if the typing proof exists and 
if it exists we can compute it.
\end{enumerate}

%Any proof $\Pi':\Gamma \vdash  t :T$ can be turned into a canonical proof 
%$\Pi':\Gamma \vdash  t :T$. Canonical proofs when they exists are unique 
%and they can be computed from $\Gamma \vdash t:T$.

Well-typed terms are closed by substitution.

%10:26 20/04/2024

Our goal is to provide a set of well-formed term for $\LAMBDA$ and interpret them as partial functionals.
Some terms, those satisfying the global trace condition (to be introduced later) will be total functionals.
Our first step is to provide reduction rules for $\LAMBDA$.

%18:14 27/03/2024

\begin{definition}[reduction rules for $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
$\reduces_\beta$: $(\lambda x^A.b)(a) \reduces_\beta b[a/x]$

\item 
$\reduces_\cond$: $\cond x^\N.(f,g)(0) \reduces_\cond f$ and
$\cond x^\N.(f,g)(\Succ (t)) \reduces_\cond g[t/x]$.

\item
$\reduces$ is the context and transitive closure of $\reduces_\beta$ and $\reduces_\cond$

\item
We say that $t \reduces_\safe u$, or that $t$ reduces safely to $u$,  
if we never reduce in proper subterms of any $\cond x^\N.(f,g)$. 
%We call \emph{unsafe} a reduction inside any $\cond x^\N.(f,g)$.

\item
A term is safe-normal if all its redexes (if any) are inside some $\cond x^\N.(f,g)$.
\end{enumerate}
\end{definition}

As example. If $u = \cond x^\N. (0, (\lambda x.u)(z) )$ is as above, then $u$ is safe-normal, because
all redexes in $u$ are of the form  $(\lambda x.u)(z)$ and inside a $\cond$. 
However, the tree form of $u$ has the following branch:
$$
u, \ \ \ 
(\lambda x.u)(z), \ \ \ 
\lambda x.u, \ \ \ 
u, \ \ \ \ldots
$$
This branch is cyclic, infinite,
and it includes infinitely many $\beta$-redexes.

The reason for forbiding
reductions inside $\cond x^\N.(f,g)$ is that through $\cond$ we will-express fixed-point equations.
Therefore reductions for $\cond$ are in fact unfolding of the definition of a fixed point. 
Therefore reductions for $\cond$ can easily loop, and they are ``unsafe". 
For this reason, we first consider the minimum possible of reductions
$\cond x^\N.(f,g)(0) \reduces_\cond f$ and
$\cond x^\N.(f,g)(\Succ (t)) \reduces_\cond g[t/x]$: those on maximal $\cond$-expression.
We consider no reduction inside the arguments $f$, $g$ of $\cond$.
In a second moment, 
by adding a restriction of \emph{fairness} on reduction strategies,
we will be able to recover strong normalization also for most ``unsafe" reductions.

Some examples of reduction.
\begin{enumerate}
\item
An example of reduction of a term $v(n)$ to a normal form. 
If $n$ is any numeral and $v = \cond x^\N. (0, (\lambda x.v(x)) )$, then 
$v(n): \N$ has infinitely many $\beta$-redexes inside 
$\cond$, therefore infinitely many unsafe reductions are possible. There are only finitely many safe reduction
from $v(n)$ instead: $v(n)$ $\cond$-reduces to $(\lambda x.v(x))(n-1)$, 
this latter $\beta$-reduces to $v(n-1)$, 
then we loop: $v(n-1)$ reduces to $v(n-2)$ in one $\cond$-step and one $\beta$-step and so forth.
After $n$ $\cond$-reductions and 
$n$ $\beta$-reductions we get $v(0)$. With one last $\cond$-reduction we get $0$ and we stop. 
\item
The term $v(n)$ above is also an example of a strongly normalizing term.
There is the unique reduction sequence from $v(n)$, because we cannot $\cond$-reduce $\lambda x.v(x)$
before assigning either $0$ or $\Succ(u)$ to $x$. 
Thus, all reductions sequences from $v(n)$ terminate in $2n+1$ steps to the normal form $0$.
\end{enumerate}


\section{The trace of the cyclic $\lambda$-terms}
%19:34 27/03/2024
Total $\lambda$-terms will be well-typed terms $\Gamma \vdash t:A$ 
satisfying a condition call \emph{global trace condition} for the canonical proof 
$\Pi:\Gamma \vdash t:A$.
In order to define the global trace condition, 
we define a notion of trace for possibly infinite $\lambda$-terms, describing how an input of type $\N$
is used when computing an output.
The first step toward a trace is defining a connection between atoms in the
proof that $t$ is well-typed. We need first the notion of \emph{list of argument
 types} and index of atomic types for a term.

First, an example.
Assume $t : \{{x_1}^{A_1},{x_2}^{A_2}\} \vdash B_3 \rightarrow \N$. Then the list of argument types of $t$
is $A_1, A_2, B_3$, $A_1,A_2$ are named arguments with names $x_1, x_2$, and $B_3$ is an unnamed
argument. Remark that for an open term $t$ we list as ``argument types'' also the
types of the free variables. We motivate our terminology:
in a sense, $t$ is an abbreviation of the closed term $t' = \lambda  
{x_1}^{A_1},{x_2}^{A_2}.t: (  A_1,A_2,B_3 \rightarrow \N )$, and the argument types of $t'$ are
in fact $A_1, A_2, B_3$. 
The index of an atomic argument of $t$ is any $j \in \{1,2,3\}$ such that $A_j=\N$
or $B_j=\N$ respectively.

\begin{definition}[List of argument types of a term]
Assume that $\vec{A} = A_1, \ldots, A_n$, $\vec{B}=B_{n+1}, \ldots, B_{n+m}$, 
$\Gamma = \{\vec{x}:\vec{A}\}$,
and $t: \Gamma \vdash \vec{B} \rightarrow \N$.

\begin{enumerate}
\item
The \emph{list of argument types} of $t$ is $\vec{C} = \vec{A},\vec{B}$, 
the list of types of free variables and arguments of the type $ \vec{B} \rightarrow \N$ of $t$. 

\item
$A_1, \ldots, A_n$ are named arguments with names $x_1, \ldots, x_n$, and 
$B_{n+1}, \ldots, B_{n+m}$ are unnamed arguments.

\item
An \emph{index of an atomic argument} 
of $t$ is any $j \in \{1, \ldots, n+m\}$ such that $C_j = \N$.

\end{enumerate}
\end{definition}

We now define the atom connection between arguments of type $\N$ of subterms of $t$
in a proof $\Pi: t:\Gamma \vdash A$ of  $\LAMBDA$. 
The definition of  atom connection for a syntax including binders is the main contribution of this paper. 

Two arguments of type $\N$ are in
connection if and only if they receive the same global input: local input are ignored.
In many cases two corresponding argument types have the same index, but if we insert or remove
free variables or arguments the index may change.
Before providing the general definition, we discuss these special cases through examples. 

We draw in the same color two arguments of type $\N$ which are in connection. 

\subsection{Some connection examples}
\begin{Eg}\label{eg:0}\rm
An example of  atom connection for some instance of the weakening rule.
\[
\infer[(\weak)]
{  {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}, x_3:\bfColor{oldgold}{\N}
					\prove t : \bfColor{orange}{\N} \rightarrow \N}
	  {   {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N} 
					\prove t : \bfColor{orange}{\N} \rightarrow \N}
\]
\end{Eg}
Remark that the type $\N$ of the variable $x_3$ (colored in \bfColor{oldgold}{old gold}) , 
introduced by weakening, is in connection with no type in the rule $\weak$.

%20:13 15/04/2024
\begin{Eg}\label{eg:1}\rm
An example of  atom connection for the rule $\ap$.
We assume that $a$ is \emph{not} a variable.
\[
\infer[(\ap)]
{  {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}
					\prove f(a) : \bfColor{orange}{\N} \rightarrow \N}
    {
	  {   {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}
					\prove f : \bfColor{oldgold}{\N}, \bfColor{orange}{\N} \rightarrow \N}
      {\ \ \ \ \   x_1: \bfColor{red}{\N}, x_2: \bfColor{blue}{\N}
					\prove a : \N}
	}
\]
\end{Eg}
Remark that the first argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
is in connection with no argument in the rule $\ap$.
The reason is that in the term $f(a)$,
the first argument of $f$ receives a value from the value $a$ which is local to the term $f(a)$.
However, the first argument of $f$ can be in connection with some argument higher in the proof. 
%13:21 15/04/2024

\begin{Eg}\label{eg:2}\rm
An example of  atom connection for the rule $\cond$.
\[
\infer[(\cond)]
{  {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}
					\prove \cond x^\N.(f,g) : \bfColor{oldgold}{\N} \rightarrow \N}
    {
      {   {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}
					\prove f : \N}
	  {   {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}, x^\N  : \bfColor{oldgold}{\N} 
					\prove g : \N}
    }
\]
\end{Eg}
Remark that the first argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
is in connection the type of the free variable $x$ in the premise for $g$,
but it is in connection with no argument in the  in the premise for $f$.

\subsection{A formal definition of atom connection}
We define an injection $$\ins:\N,\N \rightarrow\N$$
by $\ins(a,x)=x+1$ if $x \ge a+1$, and $\ins(a,x)=x$ if $x\le a$.
The role of $\ins$ is inserting one space for a new index of argument type.

\begin{definition}[Atom connection in a proof of  $\LAMBDA$]
Assume $\vec{A} = A_1, \ldots, A_n$, $\vec{B}=B_1, \ldots, B_m$, $\Gamma = \vec{x}:\vec{A}$,
and $\Gamma \vdash t:\vec{B} \rightarrow \N$.

For each atom index $k$ in $t$, each immediate subterms $t'$ of $t$ 
each atom index $k'$ in $t'$ we define the relation: ``$k',t'$ the successor of $k,t$". We require:
\begin{enumerate}
\item
if $t$ is obtained by a rule $\weak$ from $t'$, adding a variable in position $a+1$,   
then $k = \ins(a,k')$.
\item
if $t=f(a)$ and $a$ is not a variable and $t'=f$ 
then $k' = \ins(n,k)$. If $t'=a$ then $k'=k$ and $k' \le n$.
\item
if $t=\cond x^\N.(f,g)$ and $t'=f$ 
then $k' = \ins(n,k)$. If $t'=g$ then $k'=k$.
\end{enumerate}
We require $k = k'$ in all other cases, 
which are: $\Succ $, $\lambda$, $\etaRule$.
\end{definition}

If we move up in a $\etaRule$ the type of one free variable corresponds to the type of one argument.
In a $\lambda$-rule it is the other way round. The index of two corresponding argument types
is the same for both rules. 
Below we include some examples. 
We draw in the same color two arguments of type $\N$ which are in connection. 


\begin{Eg}\label{eg:3}\rm
Atom connection for $\etaRule$.
We assume that $x$ is a variable.
\[
\infer[(\etaRule)]
{  {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}, x^\N  : \bfColor{oldgold}{\N}
					\prove f(x) : \bfColor{orange}{\N} \rightarrow \N}
	  {   {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}
					\prove f : \bfColor{oldgold}{\N}, \bfColor{orange}{\N} \rightarrow \N}
\]
\end{Eg}
Remark that the first argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
in the premise is in connection with the last variable type in the conclusion of the rule.

\begin{Eg}\label{eg:4}\rm
Atom connection for  $\lambda$-rule.
We assume that $x$ is  a variable.
\[
\infer[(\ap)]
{  {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}
					\prove \lambda x^\N.b : \bfColor{oldgold}{\N} \rightarrow \N}
	  {   {x_1}^\N : \bfColor{red}{\N},{x_2}^\N : \bfColor{blue}{\N}, x^\N  : \bfColor{oldgold}{\N}
					\prove b : \N}
\]
\end{Eg}
Remark that the first argument of $\lambda x^\N.b$ (colored in \bfColor{oldgold}{old gold}) 
in the conclusion is in connection with the last variable type in the premise of the rule.
\\


The connection on atoms in a proof $\Pi:\Gamma\vdash $ defines a graph $\Graph(\Pi)$ 
whose nodes are all pairs $(k,u)$, with $u$ subterm of $t$ and $k$ index of some atomic argument of  $u$.
We define a trace as a (finite or infinite) path in the graph $\Graph(\Pi)$.

\begin{definition}[Trace for well-typed terms in $\LAMBDA$]
\begin{enumerate}
\item
A path $\pi$ in $t$ is any list $t_0, \ldots, t_n$ of subterms of $t$ 
such that $t_0 = t$ and each $t_{i+1}$ is an immediate subterm of $t_i$. 

\item
Assume $\pi =t_0, \ldots, t_n, \ldots$ is a branch of $t$, finite or infinite. 
A finite or infinite \emph{trace} $\tau$ of $\pi$ is a list 
$\tau = (k_m,t_m), \ldots, (k_n,t_n), \ldots$ such that for each $i=m,\ldots, n,\ldots$:
\begin{enumerate}
\item
$k_i$ is the index of an atomic type of $t_i$
\item
if $i+1$ is an index of $\tau$ then $k_{i+1},t_{i+1}$ is in connection with $k_i, t_i$ in $\Pi$.
\end{enumerate}

\end{enumerate}
\end{definition}

%20:50 15/04/2024

\section{The circular system $\CTlambda$}
We define a subset $\CTlambda$ of the set $\WTyped$ of well-typed term,
by adding the global trace condition and regularity. 
For the terms of $\CTlambda$ we will prove
strong normalization, church-rosser for terms of type $\N$, and the fact that every term of type
$\N$ is a numeral. 
As a consequence, terms $\CTlambda$ will be interpreted as total functionals. 

From the atom connection we define the global trace condition and terms $\CTlambda$.

We say that a tree is regular if it has finitely many subtrees. $t=\cond x^\N.(0,t)$ is an infinite regular tree,
with subtrees: $t$, $0$.

\begin{definition}[Global trace condition and terms of $\CTlambda$]
\begin{enumerate}
\item
Assume $\tau = k_m, \ldots, k_n$ is a trace of $\pi =t_0, \ldots, t_n$ and $i=m,\ldots, n$.
$\tau$ is progressing in $i$ if $t_i=\cond x^\N.(f,g)$ for some $f$, $g$,
and $k_i$ is the index of the first \emph{unnamed} argument the $\cond$-rule, 
otherwise $\tau$ is not progressing in $i$.

\item
$t$ satisfies the global trace condition if for all infinite paths $\pi$ in $t$ 
there is some infinitely progressing path $\tau$ in $\pi$.

\item
Terms of $\CTlambda$ are all well-typed terms which are regular trees (having finitely many subtrees), 
and satisfy the global trace condition.

\end{enumerate}
\end{definition}


\section{Examples of terms of $\CTlambda$}

\subsection{The sum map}
%\Daisuke{Add sum (start)}
As a first example of term of  $\CTlambda$ we can provide a term $\Sum$ computing the sum on $\N$,
which is an infinite term defined by $\Sum = \lambda x^\N.\cond z.(x,\Succ(\Sum(x)(z)))$.
This term is regular with subterms 
$$
\Sum, \  \  \ \cond z.(x,\Succ(\Sum(x)(z))), 
\  \  \ x, \  \  \ \Succ(\Sum(x)(z)),  \  \  \ \Sum(x)(z), \  \  \ \Sum(x)
$$
This term is well-typed by the following circular derivation with a back edge from the $(\dagger)$ above to the $(\dagger)$ below.
The only infinite path contains a progressing trace, a sequence of $\N$'s colored in 
\bfColor{oldgold}{old gold}. 
\[
\infer[\lambda]{
  \vdash \Sum:\N \rightarrow \bfColor{oldgold}{\N} \rightarrow \N\ 
(\bfColor{oldgold}{\dagger})
}{
  \infer[\cond]{
    x^\N : \N \vdash \cond z.(x,\Succ(\Sum(x)(z))): \bfColor{oldgold}{\N} \rightarrow \N
  }{
    \infer[\var]{
      x^\N : \N \vdash x^\N
    }{}
    &
    \infer[\Succ]{
      x^\N:\N, z^\N : \bfColor{oldgold}{\N} \vdash \Succ(\Sum(x)(z)): \N
    }{
      \infer[\eta]{
       x^\N:\N, z^\N : \bfColor{oldgold}{\N} \vdash \Sum(x)(z): \N
      }{
        \infer[\eta]{
          x^\N : \N \vdash \Sum(x): \bfColor{oldgold}{\N} \rightarrow \N
        }{
          \vdash \Sum: \N \rightarrow \bfColor{oldgold}{\N} \rightarrow \N\ 
(\bfColor{oldgold}{\dagger})
        }
      }
    }
  }
}
\]

%\Daisuke{Add sum (end)}\\

%10:43 16/04/2024

\subsection{The Iterator}
A second example. We define a term $\Iter$ of  $\CTlambda$ computing the iteration of maps on $\N$.
We define a normal term $\Iter:(\N \rightarrow \N), \N,\N \rightarrow \N$ such that
$\Iter(f,a,n)=f^n(a)$ for all $n \in \N$. 
We have to to solve the equations $\Iter(f,a,0) = a$ and $\Iter(f,a,\Succ (t)) = f(\Iter(f,a,t))$.
We solve them with $\Iter = \lambda f, a, x.I$
with $I = (\cond x^\N. (a, f(I) ))(x)$.

The term is well-typed and regular by definition. We check the global trace condition. 
We mark the last unnamed argument $\N$ of $\Iter$. The mark moves to $x$ in $I$.
 Through a $\etaRule$-rule the mark moves to the unique unnamed argument $\N$ of  
$ \cond x^\N. (a, f(I) )$.
The mark either moves to the name $x$ in the context of $a$ and there it stops, or 
it progresses and moves to $x$ in the context of $f(I)$, then in the context of $I:\N$.
%??????????????? 10:30 24/03/24
Now we loop: if the path continues forever, then after infinitely many step the mark from which we started 
progresses infinitely many times, each time it crosses a $\cond$-rule.



\subsection{The Interval Map}
A third example. We simulate lists with two variables $\nil:\alpha$ and 
$\cons:\N,\alpha \rightarrow \alpha$. We recursively define a notation for lists by $[]=\nil$,
$a @ l=\cons(a,l)$ and $[a,\vec{a}] = a @ [\vec{a}]$. We add no elimination rules for lists, though,
only the variables $\nil$ and $\cons$.

We will define a term $\Interval$ with one argument $f:\N \rightarrow \N)$ and three argument
$a^\N,x^\N,y^\N$, such that 
$$
\Interval(f,a,n,m) = [f^n(a), f^{n+1}(a), \ldots, f^{n+m}(a)]
$$ 
for all $n,m \in \Num$. 
We have to to solve the recursive equations 
$$
\Interval(f,a,x,0) = [\Iter(a,f,x)]
\ \ \ \ \ \ 
\Interval(f,a,x,\Succ (t)) = \Iter(a,f,x) @ \Interval(f,a,\Succ(x),t)
$$ 
We solve them with $\Interval = \lambda f,a.v$,
where $v:\N,\N\rightarrow \N$, 
$v = \lambda x.\cond y. (\ [w],  \  w @ v(\Succ (x),y) \ )$ and $w=\Iter(f,a,x)$.

The term is well-typed and regular by definition. We check the global trace condition.
We mark the last unnamed argument $\N$ of $\Interval$.
The mark moves to the last unnamed argument $\N$ of  
$v:\N,\N \rightarrow \N$. 
We unfold $v$ to $\lambda x.\cond y. 
(\ [w],  \  [w] @ v(\Succ (x),y)) \ )$
The mark progresses and moves to the name $y$ in the context of the body of the $\lambda$-abstraction,
then to $y$ in the context of $[w]$ or of $ [w] @ v(\Succ (x),y))$,
then in the context of $\nil$ and stops, or in the context of $w=\Iter(f,a,x):\N$, 
for which we already checked the global trace condition, or in the context of $v(\Succ (x),y)):\N$. 

Then the mark moves from the named argument $y$ of $v(\Succ (x),y):\N$ to the unique 
unnamed argument $\N$ of $v(\Succ (x))$, 
and eventually to the second argument of $v:\N,\N\rightarrow \N$. 
From $v$ we loop: after infinitely many step either we reached some $w=\Iter(f,a,x)$ 
and we find some infinite progressing trace inside it, or the
mark from which we started progresses infinitely many times through the $\cond$-rule inside $v$. 
In both cases we have the global trace condition.

We have infinitely many nested $\beta$-reduction $(\lambda x. \ldots)(\Succ (x))$.
We can remove all of them in a single step. Inside the $\beta$-redex number $k$ we obtain a sub-term
$w[\Succ (x)/x]\ldots[\Succ (x)/x]$ (substitution repeated $k$ times).
The result is $w[\Succ ^k(x)] = \Iter(f,a,\Succ ^k(x))$.
The nested substitution produce new $\beta$-reductions 
$\Iter(f,a,\Succ ^k(x)) = (\lambda x.I)(\Succ ^k(x))$ for all $k \in \N$.
This is a non-regular term: we have infinitely many pairwise different 
sub-terms $x,\Succ (x),\Succ^2(x), \Succ^3(x), \ldots$.
We need infinitely many steps to normalize all $\Iter(f,a,\Succ^k(x))$ to $f^k(I)$, 
even if we allow to reduce all $\beta,\cond$-redexes at the same time.
Also the normal form is not regular: it contains all terms $f^k(I)$ for $k \in \N$, hence
infinitely many pairwise different terms. These infinite sub-terms are of a particulary simple form, though. 
They are obtained by the repeating $k$ times the assignment $z:=f(z)$, then applying $z:=I$ once
to the result.

Apparently, $\Interval$  
is some term of $\CTlambda$ which cannot be normalized in finite time, not even if we allow
infinite parallel reductions without any "safety" restriction. 
The normal form is produced \emph{only in the limit}
and it is \emph{not regular}. If we allow to reduce infinitely many nested $\beta$-redexes in one step, also
the intermediate steps of the infinite reduction of $\Interval$ are not regular.



\section{Subject reduction for terms of $\CTlambda$ of type $\N$}
%\Daisuke{SR start}
\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
\\
\emph{(Here we should fill this part)}
\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
%\Daisuke{SR end}

%15:12 16/04/2024


\section{Weak normalization for closed terms of $\CTlambda$ of type $\N$}
\label{section-weak-normalization}
%\Daisuke{WN start}
In this section we prove that every closed term of $\CTlambda$
 (that is, well-typed, regular and with the global trace condition) normalizes with finitely many "safe" steps
to some numeral $n \in \N$.
In the following, we explicitly write $t[x_1,\ldots,x_n]$,
when each free variable in $t$ is some $x_i$, 
and, under this notation, we also write $t[a_1,\ldots,a_n]$ instead of $t[a_1/x_1,\ldots,a_n/x_n]$. 
We recall that we denote with $\Nat$ the set of all numerals, namely the set of all terms of the form
$\Succ^n(0)$ for some $n\in \N$.

We define closed total terms as in Tait's normalization proof, and we define values.
Values are always closed total terms,
the only different between values and closed total terms 
is that if a value has type $\N$ then it is a numeral.

Here is the informal definition. We define values of type $\N$, which are numerals (hence closed term). 
We define total terms $t$ of type $\N$, which are
the closed terms of type $\N$ evaluating in at least one reduction path to a numeral, and
include values of type $\N$. 
Closed total terms and values of type $t:\alpha$ (with $\alpha$ type variable) coincide, 
both are all closed terms.
Closed total terms and values of type $t:A \rightarrow B$ coincide, 
both are the terms mapping values to total terms. 
An open term is total if all substitutions of free variables with values produce a closed \emph{total} term.

Below is the formal definition of values, closed total terms and total terms.

\begin{definition}[Values and total term]
  We define values and closed total terms on values by induction on types. 
  \begin{enumerate}
  \item
    A closed term $t:\N$ or is a \emph{value} if and only if $t \in \Nat$ ($t$ is some numeral).
  \item
    A closed term $t:\N$ is \emph{closed total}
    if and only if $t \safeReduces^* u$ for some $u\in \Nat$.
  \item
    Closed terms and values of type $t:\alpha$ (type variable) coincide, both are all closed terms.
   \item
    A closed term $t:A\rightarrow B$ is a \emph{value}
    if and only if $t(a)$ is closed total for any value $a:A$.
   \item
    Closed terms and values of type  $t:A\rightarrow B$ coincide.
  \item
    A term $t[\vec{x}]:C$ (i.e., whose free variables are in $\vec{x}:\vec{A}$), is
    \emph{total} if and only if $t[\vec{a}]$ is closed total for any values $\vec{a}$ of type $\vec{A}$.
  \end{enumerate}
\end{definition}

We can assign values to all arguments of a term and to any sub-term chain.

\begin{definition}[trace-compatible assignment]
 Assume $t \in \WTyped$ is a well-typed term of $\LAMBDA$ in the context 
 $\Gamma = \vec{x}:\vec{B}$.
 Assume $t[\vec{x}]:\vec{A}\rightarrow\N$ has argument types $\vec{B},\vec{A}$ in $\Gamma$.
Assume $\pi = (t_1, \ldots, t_n) \in \SubTerm(t)$ is any chain of immediate subterms of $t$.
 \begin{enumerate}
 \item
 A value assignment $\vec{v}$ for $t$ in $\Gamma$ is any vector 
$\vec{v}=\vec{u},\vec{a}:\vec{B}\vec{A}$ of closed values.
 \item
 A trace-compatible assignment $\vec{v} = (\vec{v_1}, \ldots, \vec{v_n})$ 
  for $\pi$ is any vector of value assigments, each $\vec{v_i}$ value assignment for $t_i$, 
  which satisfies the following condition. 
  For all $j$ argument of $t_i$ assigned to $\Succ^{a}(0)$, 
  all  $k$ argument of $t_{i+1}$ assigned to $\Succ^{b}(0)$, if $j$ corresponds to $k$ then:
 \begin{enumerate}
 \item
 if $j$ progresses to $k$ we have $a=b+1$
 \item
 if $j$ does not progress to $k$ we have $a=b$.
 \end{enumerate}
 
\end{enumerate}
\end{definition}

If an infinite path has a trace-compatible assignment, then all traces of the path progress only finitely many times.

\begin{proposition}[Trace assigment]
\label{prop:trace_assign}
If $t \in \WTyped$, $\pi \in \Tree(t)$ is an infinite path, $\rho$ is a value assignment to $\pi$.
\begin{enumerate}
\item
\label{prop:trace_assign1}
If an argument $j$ of some $t_i \in \pi$ has type $\N$ and value $\Succ^n(0)$, then a trace
from $j$ progresses at most $n$ times.
\item
\label{prop:trace_assign2}
$t \not \in \GTC$.
\end{enumerate}
\end{proposition}

\begin{proof}
\begin{enumerate}
\item
%\label{prop:trace_assign1}
By definition of trace-compatible assignment, whenever the trace progresses, 
the natural number $n$ decreases by $1$,
and whenever the trace does not progress, the the natural number $n$ remains the same.
Thus, a trace from $j$ progresses at most $n$ times, as we wished to show.
\item
%\label{prop:trace_assign2}
By point \ref{prop:trace_assign1} above, 
no trace from any argument in any term of the branch $\pi$ of $\Tree(t)$ progresses infinitely many times.
By definition of $\GTC$, we conclude that $t \not \in \GTC$. 
\end{enumerate}
\end{proof}

Closed total terms are closed by safe reductions and by application. 

\begin{lemma}\label{lem:total_value}
  \begin{enumerate}
  \item\label{lem:total_value1}
    Let $t:A$ be a closed term and $t \safeReduces u$.
    If $u$ is total, then so is $t$.
  \item\label{lem:total_value1bis}
    Let $f:A \rightarrow B$, $a:A$ be closed \emph{total} terms.
    Then so is $f(a)$.
  \item\label{lem:total_value2}
    Let $t[\vec{x}]:\vec{A}\rightarrow\N$ be a term,
    whose all free variables are $\vec{x}:\vec{B}$,
    and $\vec{u}:\vec{B}$ and $\vec{a}:\vec{A}$ be closed values.
    If all $t[\vec{u}]\vec{a}:\N$ are total, then $t[\vec{x}]$ is total. 
  \end{enumerate}
\end{lemma}
\begin{proof}
\begin{enumerate}

\item
  \emph{Point \ref{lem:total_value1}} is shown by induction on $A$. 
By the subject reduction property, $u$ has type $A$.
\begin{enumerate}
\item
  We first show the first \emph{base case}, namely when $A =\N$.
  By the assumption, $u$ is closed total.
  By definition of $u$ closed total, we have $t \safeReduces u \safeReduces^* n$ for some $n\in\Num$. 
  Hence $t:\N$ is total.
\item
  We first show the second \emph{base case}, namely when $A =\alpha$.
  Both $t$ and $u$ are closed terms of type $\alpha$, therefore are closed total terms.
\item
  We show the \emph{induction case}, namely when $A = (A_1\rightarrow A_2)$.
  Take arbitrary closed value $a:A_1$. Then we have $t(a) \safeReduces u(a)$ and 
  $u(a):A_2$ is total by the assumption that $u$ is total.
  Hence by the induction hypothesis $t(a)$ is total. 
  We obtain that $t:A_1\rightarrow A_2$ is total. 
\end{enumerate}

  \item
\emph{Point \ref{lem:total_value1bis}} is shown by case reasoning.
Assume that$f:A \rightarrow B$, $a:A$ are closed total terms, in order to prove
that $f(a)$  is closed total .

Assume $A$ is a variable type or an arrow type. 
Then $a:A$ is a value because values and closed total terms of type $A$
coincide, therefore $f(a):A$ is closed total by definition of closed total.

Assume $A=\N$. Then $a \safeReduces n$ for some $n \in \Num$ by definition of closed total.
$f(n)$ is closed total by definition of closed total. $f(a)$ is closed total by $f(a) \safeReduces f(n)$
and point \ref{lem:total_value1bis} above.

\item  
  \emph{Point \ref{lem:total_value2}} is shown by induction on $|\vec{A}|$.
\begin{enumerate}
\item
  The \emph{base case} $|\vec{A}| = 0$ is immediately shown by the definition.
\item
  We show the \emph{induction case}. Let $\vec{A} = A_0\vec{A'}$.
  Take arbitrary values $\vec{u}:\vec{B}$, $\vec{a'}:\vec{A'}$, and $a_0:A_0$. 
  By the assumption, we have $t[\vec{u}]a_0\vec{a'}:\N$ is closed total for all values $\vec{a'}$. 
  Then $t[\vec{u}]a_0:\vec{A'}\rightarrow\N$ is total 
  by the induction hypothesis on $\vec{A'}\rightarrow \N$.
  By definition $t[\vec{u}]:\vec{A}\rightarrow\N$ is closed total,
  and so by definition $t[\vec{x}]$ is total, as we expected.
\end{enumerate}

\end{enumerate}
\end{proof}

%10:28 19/04/2024

Let $\Pi$ be a proof of $\Gamma\vdash t:A$ and $e$ be a node of $\Pi$, that is, a chain  
$(t_1, \ldots, t_n) \in \Tree(t)$ of immediate
subterms of $t$ with $t_1 = t$.
We write $\Pi(e)$ for $\Gamma_n\vdash t_n:A_n$ with $\Gamma_n$ inherited contex of 
$t_n$ and $A_n$ the type assigned by $\Pi$ to $t_n$.

\begin{theorem}
  Assume $\Pi:\Gamma\vdash t:A$.
  If $t$ is \emph{not} total, then $t \not \in \GTC$, i.e.:
  there is some infinite path in $\Pi$ with no infinite progressing trace. 
\end{theorem}

%19:01 16/04/2024

\begin{proof}
  Assume that $t$ is not total
  and $t: \vec{x}:\vec{D}\vdash\vec{A}\rightarrow\N$ 
  has a proof $\Pi$ in order to show that $t \not \in \GTC$.
  By Proposition \ref{prop:trace_assign}.\ref{prop:trace_assign2} it is enough to prove that
  $\Pi$ has some infinite path $\pi$ and some trace-compatible assignment $\rho$ for $\pi$.
  By \ref{lem:total_value2} of Lemma~\ref{lem:total_value},
  there exist closed values $\vec{a}:\vec{A}$ and $\vec{d}:\vec{D}$ such that
  $t[\vec{d}]\vec{a}$ is not total. 
  By induction on $i$, we construct a term $e_i$ for each natural number $i$,
  and a value assignment $\vec{v_i} = (\vec{d_i},\vec{a_i})$ for $e_i$, such that 
  such that $\pi=(e_1, \ldots, e_n)$ is a chain of immediate subterms from $e_1  = t$
  and $(\vec{v_1},\ldots,\vec{v_n})$ is a trace-compatible assignment for $\pi$.
  We assume that:
  \begin{itemize}
  \item[(i)]
%15:38 19/04/2024
    $e_i$ is a node of $\Pi$, whose last term is 
    $t_i: \vec{x_i}:\vec{D_i}\vdash\vec{A_i}\rightarrow\N$ is
    at the node $e_i$ in $\Pi$, and $e_{i+1}$ is a child node of $e_i$ in $\Pi$; 
  \item[(ii)]
    $t_i$ is not total;
  \item[(iii)]
    $\vec{d_i}:\vec{D_i}$ and $\vec{a_i}:\vec{A_i}$ are closed values
    such that $t_i[\vec{d_i}]\vec{a_i}$ is not total;
  \item[(iv)]
    there is a trace-compatible assignment from
    ($\vec{d_i};\vec{a_i}$) to ($\vec{d_{i+1}};\vec{a_{i+1}}$), for any $i\ge 0$, in $\Pi$.
    Moreover, if $i$ is a progress point, namely $t_i$ is of the form $\cond x^\N.(f,g)$ and $t_{i+1}$ is $g$,
    then $\vec{a_i} = \Succ(m')\vec{a'}$, $\vec{d_{i+1}} = \vec{d_i}m'$, and
    a trace passes from $\Succ(m')$ to $m'$. 
    %\Daisuke{mynote:write this more clearly}
  \end{itemize}
  
  We first define $(e_1,\vec{d_1},\vec{a_1})$ for the root node $t$ of $\Pi$.
  We choose $e_1 = t$ and $(\vec{d},\vec{a})$ values such that $t[\vec{d}](\vec{a})$ is not total.
  Points (i), (ii), (iii), (iv) are immediate.

  Next, assume that $(e_i,\vec{d_i},\vec{a_i})$ is already constructed.
  Then we define $(e_{i+1},\vec{d_{i+1}},\vec{a_{i+1}})$ by the case analysis on
  the last rule for the node $e_{i+1}$ in $\Pi$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPARENTLY THE CASE $\struct(f)$ CAN BE SIMPLIFIED TO WEAKENING-Stefano
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
\item
  The case of $\weak$, namely
  $\Pi(e_i) = t[y_{f(1)}/x_1,\ldots,y_{f(n)}/x_n]:\Delta\vdash \vec{A_i}\rightarrow\N$
  is obtained from $\Gamma\vdash t:A$, where
  $\Gamma = x_1:C_1,\ldots,x_n:C_n$, $\Delta = y_1:B_1,\ldots,y_m:B_m$, 
  $f:\{1,\ldots,n\}\to\{1,\ldots,m\}$ is an injection, 
  and $x_i^{C_i}=y_{f(i)}^{B_{f(i)}}$ for all $1\le i\le n$.
  By the induction hypothesis and $(b)$, the conclusion
  $t[y_{f(1)}/x_1,\ldots,y_{f(n)}/x_n][d_{i,f(1)}/y_{f(1)},\ldots,d_{i,f(n)}/y_{f(n)}]\vec{a_i}:\N$ 
  of $\weak$ is not total, where $\vec{d_i} = d_{i,1}\ldots d_{i,m}$.
  Then define $e_{i+1}$ as the unique parent node of $e_i$, and we
  also define $\vec{d_{i+1}}$ and $\vec{a_{i+1}}$ by $d_{i,f(1)}\ldots d_{i,f(n)}$
  and $\vec{a_i}$, respectively. 
  We obtain (i), (ii), and (iii) for $i+1$, as expected.
  We also have (iv) since the connection, determined by $f$, from
  $(d_{i,1}\ldots d_{i,m};\vec{a_i})$ to 
  $(\vec{d_{i+1}};\vec{a_{i+1}}) = (d_{i,f(1)},\ldots d_{i,f(n)};\vec{a_i})$
  is trace compatible. 

\item
  The case of $\var$-rule, namely $\Pi(e_i) = \Gamma\vdash x_j:C_j$, 
cannot be, because $t_i = [x_j/d_j] = d_j$ is closed total by assumption on $\vec{d}$.

\item
  The case of $0$-rule, namely $\Pi(e_i) = \Gamma\vdash 0:\N$, cannot be, because $t_i = 0$ is total
because it is a numeral.

\item  
  The case of $\Succ$-rule, namely $\Pi(e_i) = \Gamma\vdash \Succ(t_{i+1}): \N$ is obtained from
  $\Gamma\vdash t_{i+1}: \N$. $\vec{a_i}$ is empty, and
  by the induction hypothesis $\Succ(t_{i+1}[\vec{d_i}]):\N$ is not closed total.
  Then, by the definition of closed total, $t_{i+1}[\vec{d_i}]$ is not closed total. 
  Define $e_{i+1}$ as the unique parent node of $e_i$, and
  also define $\vec{d_{i+1}}$ and $\vec{a_{i+1}}$ by $d_i$ and the empty list, respectively. 
  We obtain (i), (ii), (iii), and (iv) for $i+1$, as expected.

\item
  The case of $\ap$-rule, namely 
  $\Pi(e_i) = \Gamma\vdash t[\vec{x}](u[\vec{x}]): \vec{A}\rightarrow\N$ is obtained from
  $\Gamma\vdash t[\vec{x}]: B \rightarrow \vec{A}\rightarrow\N$ 
  and $\Gamma\vdash u[\vec{x}]: B$.
  By the induction hypothesis, $t[\vec{d_i}](u[\vec{d_i}])\vec{a_i}:\N$ is not total.
  We argue by case on the statement: \emph{$u[\vec{d_i}]:B$ is closed total}.

\begin{enumerate}
\item
  We first consider the subcase that \emph{$u[\vec{d_i}]:B$ is closed total}.
  We define $a':B$ by $a' = n\in\Num$ such that $u[\vec{d_i}] \safeReduces^* n$ if $B=\N$,
  by $a' = u[\vec{d_i}]$ otherwise. By lemma \ref{}.\ref{}, $a'$ is a value.
  Then define $e_{i+1}=t[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = a',\vec{a_i}$. 
  Using Lemma~\ref{lem:total_value}, we obtain (i), (ii), (iii) for $i+1$, as expected. 
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};a',\vec{a_i})$ is
  trace-compatible: all connected arguments of type $\N$ of $e_{i}$ and $e_{i+1}$ are the same,
  because the only fresh argument of $e_{i+1}$ is $a'$ and no argument of $e_i$ is connected to it.
\item
  Next we consider the subcase that \emph{$u[\vec{d_i}]:B$ is not closed total}.
  By lemma \ref{}.\ref{}
  there is a sequence of values $\vec{a'}$ such that $u[\vec{d_i}]\vec{a'}:\N$ is not total.
  Define $e_{i+1}=u[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};\vec{a'})$ is
  trace compatible: all connected arguments of type $\N$ of $e_{i}$ and $e_{i+1}$ are 
  in $\vec{d_i}$ and therefore are the same.
 \end{enumerate}

\item
  The case of $\eta$-rule, namely 
  $\Pi(e_i) = f[\vec{x}](x): \Gamma,x^\N\vdash \vec{A}\rightarrow\N$ is obtained from
  $f[\vec{x}]:\Gamma\vdash N\rightarrow \vec{A} \rightarrow \N$, where
  $(x^\N:\N)\not\in\Gamma$.
  By the induction hypothesis, $f[\vec{d'}]d\vec{a_i}:\N$ is not total,
  where $\vec{d_i} = \vec{d'},d$ and $d$ is the value of the argument type of $x^\N$.
  Define $e_{i+1}$ as the unique parent node of $e_i$, and
  also define $\vec{d_{i+1}}$ by $\vec{d'}$ and define $\vec{a_{i+1}}$ by $d,\vec{a_i}$. 
  We obtain (i), (ii), and (iii) for $i+1$, as expected.
  We also have (iv) since the connection from
  $(\vec{d_i};\vec{a_i}) = (\vec{d'},d;\vec{a_i})$ to
  $(d_{i+1};\vec{a_{i+1}}) = (\vec{d'};d\vec{a_i})$
  is trace compatible: all connected argument in $\vec{d_{i}},\vec{a_{i}}$ and 
  $\vec{d_{i+1}},\vec{a_{i+1}}$ are the same. The only difference between the two assignments
  is that the value $d$ of the last argument type $\N$ is moved to the value $d$ 
  of the first unnamed argument of $f$. 

\item
  The case of $\lambda$-rule, namely
  $\Pi(e_i) = \lambda x^A.(t_{i+1}[\vec{x},x]):
    \Gamma\vdash A, \vec{A} \rightarrow \N$ is obtained from
  $t_{i+1}[\vec{x},x^A]:\Gamma,x^A\vdash \vec{A}\rightarrow\N$.
  By the induction hypothesis, $(\lambda x.(t_{i+1}[\vec{d_i},x]))a\vec{a'}:\N$ is not total,
  where $\vec{a_i} = a\vec{a'}$.
  Then, by Lemma~\ref{lem:total_value}, $t_{i+1}[\vec{d_i},a]\vec{a'}$ is not total. 
  Define $e_{i+1}$ as the unique parent node of $e_i$, and
  also define $\vec{d_{i+1}} = \vec{d_i},a$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i}) = (\vec{d_i};a\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i}a;
    \vec{a'})$ is trace-compatible: all connected argument in $\vec{d_{i}},\vec{a_{i}}$ and 
  $\vec{d_{i+1}},\vec{a_{i+1}}$ are the same. The only difference between the two assignments
  is that the value $d$ of the first unnamed argument of $t_i$ is moved to the value $d$
  of the last argument type $\N$.
  This is the opposite of the movement we have in the $\etaRule$.

\item  
  The case of $\cond$-rule, namely
  $\Pi(e_i) = \cond x^\N.(f[\vec{x}],g[\vec{x},x]):
    \Gamma\vdash C\rightarrow\vec{A}\rightarrow\N$
  is obtained from 
  $f[\vec{x}]:\Gamma\vdash \vec{A}\rightarrow\N$
  and
  $g[\vec{x},x]:\Gamma,x^\N\vdash \vec{A}\rightarrow\N$. 
  By the induction hypothesis, $\cond x^\N.(f[\vec{d_i}],g[\vec{d_i},x])m\vec{a'}:\N$ is not total,
  where $\vec{a_i} = m\vec{a'}$ and $m \in \Nat$. We argue by cases on $m$.
\begin{enumerate}
\item
  We first consider the \emph{subcase $m=0$}.
  Define $e_{i+1}$ by the parent node whose term is $f[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected. 
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})
 =(\vec{d_i};0\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};\vec{a'})$
  is trace compatible: each argument of $e_i$ is connected to some equal argument of $e_{i+1}$,
  the first argument of $e_i$ disappears but it is connected to no argument in $f$.
\item
  Next we consider the \emph{subcase $m=\Succ(m')$}. 
  Define $e_{i+1}$ by the parent node whose term is $g[\vec{x},x]$,
  and define $\vec{d_{i+1}} = \vec{d_i},m'$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})
  =(\vec{d_i};\Succ(m'),\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i},m';\vec{a'})$
  is trace compatible: each argument of $e_i$ is connected to some equal argument of $e_{i+1}$,
  but for the argument $m$ of $e_i$ which is connected to $m'$ in the last argument type $\N$.
  This is fine because in the second premise of a $\cond$ 
  the trace progress. This requires that \emph{the numeral $m$ decreases by $1$}, as indeed it is the case.
\end{enumerate}

\end{enumerate}

  Hence, by the above construction, we have an infinite path $\pi = (e_1,e_2,\ldots)$ in $\Pi$
 and a trace-compatible assignment, as we wished to show.

%  Since $\Pi$ satisfies the global trace condition, $\vec{e}$ contains a progressing trace
%  $(k_{m},k_{m+1},\ldots)$, where, for each $m\le i$, $k_i$ is an atom index of $t_i$, 
%  and $k_{i+1},t_{i+1}$ is the successor of $k_i,t_i$. 
%  Let $n_i$ be an numeral in $\vec{d_i},\vec{a_i}$ at index $k_i$ for each $m\le i$.
%  Then the sequence $(n_m,n_{m+1},\ldots$ decreases at each progressing point.
%  This means that it decreases infinitely many times
%  since $(k_{m},k_{m+1},\ldots)$ has infinitely many progressing point.
%  Finally we have a contradiction. 
  
\end{proof}

From this theorem we derive the weak normalization result: 
every closed term of type $\N$ reduces to some numeral for at least
one reduction path. 

\begin{corollary}
Assume  $t: \Gamma\vdash A$,
\begin {enumerate}
\item
 $t \in \GTC$ implies that $t$ is total.
\item
  For any closed $t:\N$, there is numeral $n\in\Num$ such that $t\safeReduces^* n$. 
\end{enumerate}
\end{corollary}



%\Daisuke{WN end}

\section{Uniqueness of normal form for closed terms of $\CTlambda$ of type $\N$}
\label{section-uniqueness-normal-form}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-uniqueness-normal-form}


\section{Infinite reductions}
\label{section-infinite-reductions}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-infinite-reductions}



\section{Normalization and Fairness}
\label{section-normalization-fairness}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-normalization-fairness}


\section{Relation between cyclic and non-cyclic system $T$} 
\label{section-equivalence-cyclic-non-cyclic-T}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-equivalence-cyclic-non-cyclic-T}

\section{An example: the Ackermann function} 
\label{section-ackermann}
\input{section-ackermann}

%
%\section{appendix}
%
%\begin{verbatim}
%
%To: kmr@is.sci.toho-u.ac.jp (Daisuke Kimura)
%Re: proof of Weak Normalization to an integer for CT-lambda
%Fri, 22 Mar 2024 08:25:57 +0100 
%
%    By the way, I re-checked the weak curry-howard proof, now i think that the proof 
%does not require the property p-->q, a-->b ==> p[a/x]-->q[b/x] and can be completed 
%with the notion of safe reduction.
%but in fact it would be more interesting to prove full church-rosser for Circular T-lambda, 
%as anupam does for his circular T.
%
%    About strong normalization, we can prove it for "safe" reductions, those inside no cond. 
%More in general, we know that we can have infinite reduction sequences, because we can 
%have infinitely many redexes. However, for any infinite reduction sequence sigma, I conjecture 
%we can prove a kind of stabilization of the term. After some reduction step, the term only 
%changes inside some cond nested k times. 
%
%    Namely, I conjecture that
%
%"for any cyclic lambda term t, any infinite reduction sequence (sigma(n)|n in N) with sigma(0)=t, 
%any k in N, there is a n0 in N such that for all n>=n0, the terms sigma(n) and sigma(n0)  
%coincide on all branches with at most k times cond."
%
%    Best, Stefano
%
%\end{verbatim}






\end{document}
